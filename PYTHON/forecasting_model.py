# -*- coding: utf-8 -*-
"""Forecasting Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HDhC0Nt56WuywJYTclqBGc8j_O_b9c37
"""

!pip install requests beautifulsoup4

!pip install selenium
!apt-get update # to update ubuntu
!apt install -y chromium-chromedriver
!cp /usr/lib/chromium-browser/chromedriver /usr/bin
!apt install -y python3-dev

from selenium import webdriver
from selenium.webdriver.chrome.options import Options

# Set up the Chrome WebDriver options for Google Colab
chrome_options = Options()
chrome_options.add_argument('--headless')  # Ensure the browser runs in headless mode (no UI)
chrome_options.add_argument('--no-sandbox')
chrome_options.add_argument('--disable-dev-shm-usage')

# Create the WebDriver instance with the correct setup
driver = webdriver.Chrome(options=chrome_options)  # Only pass options here, no need for 'chromedriver' path

# Navigate to the website
url = "https://trafficindex.org/chennai/"
driver.get(url)

# Wait for a specific element to be present
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

url = "https://trafficindex.org/chennai/"
driver.get(url)

# Wait for an element that confirms the page has loaded
WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, "body")))

print(driver.page_source)

!pip install matplotlib plotly

response = requests.get(url)
print(response.text)  # Check what the raw content is

import pandas as pd
import numpy as np
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# Sample dataset to simulate a time series; in practice, replace this with your actual data
data = {
    'hour': list(range(24)),  # Assuming hours 0 through 23
    'TCI': [22, 21, 23, 25, 24, 20, 19, 18, 21, 25, 26, 30, 29, 28, 27, 26, 28, 30, 32, 31, 29, 27, 26, 24]
}
df = pd.DataFrame(data)

# Ensure that 'hour' is set as a time index with hourly intervals
df['hour'] = pd.to_datetime(df['hour'], unit='h')
df.set_index('hour', inplace=True)

# If any hours are missing, this step will reindex the DataFrame and fill with NaN
# Then use interpolation to fill missing TCI values
df = df.asfreq('H').interpolate(method='linear')

# Split data into training and test sets
train_data = df['TCI'][:-1]
test_data = df['TCI'][-1:]  # Last value for comparison

# Fit ARIMA model on training data
model = ARIMA(train_data, order=(2, 1, 1))  # Adjust order based on performance
model_fit = model.fit()

# Forecast for the next hour (as an example for "tomorrow at this time")
forecast = model_fit.forecast(steps=1)

print("Forecasted Traffic Congestion Index (TCI) for the next hour:", forecast.iloc[0])

# Plot the historical data and forecasted point
plt.figure(figsize=(10, 6))
plt.plot(df.index, df['TCI'], label='Historical TCI')
plt.axvline(df.index[-1] + pd.Timedelta(hours=1), color='red', linestyle='--', label='Forecast Point')
plt.scatter([df.index[-1] + pd.Timedelta(hours=1)], [forecast.iloc[0]], color='red')
plt.title('Traffic Congestion Index (TCI) with Forecast')
plt.xlabel('Hour')
plt.ylabel('TCI')
plt.legend()
plt.show()

# Interactive plot with plotly
fig = go.Figure()
fig.add_trace(go.Scatter(x=df.index, y=df['TCI'], mode='lines', name='Historical TCI'))
fig.add_trace(go.Scatter(x=[df.index[-1] + pd.Timedelta(hours=1)], y=[forecast.iloc[0]], mode='markers', name='Forecasted TCI', marker=dict(color='red', size=10)))
fig.update_layout(title='Hourly Traffic Congestion Index (TCI) with Forecast',
                  xaxis_title='Hour of the Day',
                  yaxis_title='Traffic Congestion Index (TCI)')
fig.show()

import pandas as pd
import numpy as np
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from datetime import datetime, timedelta

# Sample dataset for a time series, replace this with your actual data if available
data = {
    'hour': list(range(24)),  # Assuming data for each hour (0-23)
    'TCI': [22, 21, 23, 25, 24, 20, 19, 18, 21, 25, 26, 30, 29, 28, 27, 26, 28, 50, 55, 60, 53, 49, 40, 35]
}
df = pd.DataFrame(data)

# Start from todayâ€™s date and time
today = datetime.now().replace(minute=0, second=0, microsecond=0)
df['hour'] = [today + timedelta(hours=i) for i in df['hour']]
df.set_index('hour', inplace=True)

# Reindex to fill in any missing hours
df = df.asfreq('H').interpolate(method='linear')

# Split data into training
train_data = df['TCI']

# Fit ARIMA model on training data
model = ARIMA(train_data, order=(2, 1, 1))  # Adjust parameters based on data
model_fit = model.fit()

# Forecast TCI for the next 24 hours
forecast_24h = model_fit.forecast(steps=24)

# Calculate the exact target time for tomorrow at 14:00
target_time = today.replace(hour=19) + timedelta(days=1)
hours_ahead = int((target_time - df.index[-1]).total_seconds() / 3600)

# Extend forecast if necessary to reach tomorrow's 14:00
forecast_full = model_fit.forecast(steps=hours_ahead)
forecast_target_time = forecast_full.iloc[-1]  # Get the forecasted TCI for 14:00 tomorrow

# Print the forecasted value for tomorrow's 14:00
print("Forecasted Traffic Congestion Index (TCI) for tomorrow at 14:00:", forecast_target_time)

# Plot the historical data and forecasted points
plt.figure(figsize=(10, 6))
plt.plot(df.index, df['TCI'], label='Historical TCI')
forecast_index = pd.date_range(start=df.index[-1] + pd.Timedelta(hours=1), periods=hours_ahead, freq='H')
plt.plot(forecast_index, forecast_full, label='Forecasted TCI', linestyle='--', color='orange')
plt.axvline(target_time, color='red', linestyle='--', label='Forecast for Tomorrow at 14:00')
plt.scatter([target_time], [forecast_target_time], color='red')
plt.title('Traffic Congestion Index (TCI) with Forecast for Tomorrow at 14:00')
plt.xlabel('Hour')
plt.ylabel('TCI')
plt.legend()
plt.show()

# Interactive plot with Plotly
fig = go.Figure()
fig.add_trace(go.Scatter(x=df.index, y=df['TCI'], mode='lines', name='Historical TCI'))
fig.add_trace(go.Scatter(x=forecast_index, y=forecast_full, mode='lines', name='Forecasted TCI', line=dict(dash='dash', color='orange')))
fig.add_trace(go.Scatter(x=[target_time], y=[forecast_target_time], mode='markers', name='Forecasted TCI at 14:00 Tomorrow', marker=dict(color='red', size=10)))
fig.update_layout(title='Hourly Traffic Congestion Index (TCI) with Forecast for Tomorrow at 14:00',
                  xaxis_title='Hour of the Day',
                  yaxis_title='Traffic Congestion Index (TCI)')
fig.show()